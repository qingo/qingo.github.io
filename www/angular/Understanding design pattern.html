<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no'>
  <link rel='shortcut icon' href='/img/q.ico'>
  <title>Qingo'blog|小前端真不小</title>
  <link rel="stylesheet" href="/bower_components/elyts/dist/minified/css/elyts.css"/>
</head>
<body><section class="container"><article><h3 id="angularjs-understanding-design-pattern">AngularJS: Understanding design pattern</h3>
<p>MVC vs MVVM vs MVP.
What a controversial topic that many developers can spend hours and hours debating and arguing about.
For several years AngularJS was closer to MVC (or rather one of its client-side variants),
but over time and thanks to many refactorings and api improvements,
it&#39;s now closer to MVVM – the $scope object could be considered the ViewModel that is being decorated by a function that we call a Controller.
Being able to categorize a framework and put it into one of the MV<em> buckets has some advantages.
It can help developers get more comfortable with its apis by making it easier to create a mental model that represents the application that is being built with the framework.
It can also help to establish terminology that is used by developers.
Having said, I&#39;d rather see developers build kick-ass apps that are well-designed and follow separation of concerns,
than see them waste time arguing about MV</em> nonsense.
And for this reason, I hereby declare AngularJS to be MVW framework - Model-View-Whatever.
Where Whatever stands for &quot;whatever works for you&quot;.
Angular gives you a lot of flexibility to nicely separate presentation logic from business logic and presentation state.
Please use it fuel your productivity and application maintainability rather than heated discussions about things that at the end of the day don&#39;t matter that much.</p>
<h3 id="angularjs-">AngularJS: 理解设计模式</h3>
<p>MVC vs MVVM vs MVP
这是一个很多开发者都愿意花几个小时去争论和商议的有争议的问题。
几年来<code>AngularJS</code>接近<code>MVC</code>（或者更确切的说是一个客户端的变体），
但是随着时间的推移，感谢很多的重构和API的改善，
它更接近于<code>MVVM</code>-<code>$scope</code>对象被认为是有一个叫做<code>Controller</code>修饰的<code>ViewModel</code>。
能够分类一个框架，将其放入<code>MV*</code>之中是有一些好处的。
能够帮助开发者更加舒服的使用它的api，更加轻松的创建基于框架的应用程序的心理模型。
还有助于创建开发者使用的术语。
尽管如此，相对于看到他们浪费时间去争论<code>MV*</code>的无稽之谈，我更愿意看到开发者创建良好设计的并遵循关注点分离的“踢屁股”应用。
基于这个原因，本人特此声明，<code>AngularJS</code>是<code>MVW框架</code>-<code>Model-View-Whatever</code>。
其中<code>Whatever</code>代表“无论你做什么”。
Angular给于你很大的灵活性去更好的分离从业务逻辑到表现状态的表现逻辑。
请使用它促进你的生产效率和应用程序的可维护性，而不是成天到晚做一些不重要的争论。</p>
<h3 id="thanks-to-a-huge-amount-of-valuable-sources-i-ve-got-some-general-recommendations-for-implementing-components-in-angularjs-apps-">Thanks to a huge amount of valuable sources I&#39;ve got some general recommendations for implementing components in AngularJS apps:</h3>
<h3 id="-angularjs-">感谢大量的宝贵的来源，我已经有一些在AngularJS应用中实现组建的通用性建议：</h3>
<h4 id="controller">Controller</h4>
<ul>
<li>Controller should be just an interlayer between model and view.
Try to make it as thin as possible.</li>
<li>It is highly recommended to avoid business logic in controller.
It should be moved to model.</li>
<li>Controller may communicate with other controllers using method invocation
(possible when children wants to communicate with parent) or $emit, $broadcast and $on methods.
The emitted and broadcasted messages should be kept to a minimum.</li>
<li>Controller should not care about presentation or DOM manipulation.</li>
<li>Try to avoid nested controllers.
In this case parent controller is interpreted as model.
Inject models as shared services instead.</li>
<li>Scope in controller should be used for binding model with view and
encapsulating View Model as for Presentation Model design pattern.</li>
</ul>
<h4 id="-controller-">控制器（Controller）</h4>
<ul>
<li>控制器应该仅仅是模型和试图的中间层，使其尽可能地薄。</li>
<li>强烈建议在控制器中避免业务逻辑，它应该被转移到模型中。</li>
<li>控制器可以使用方法调用与其他控制器进行通讯（可能是当孩子想和父母沟通时），或者<code>$emit</code>、<code>$broadcast</code>、<code>$on</code>方法。</li>
<li>控制器不关心展现或者DOM操作。</li>
<li>尽可能的避免嵌套作用域。在这种情况下父控制器被解释为模型，可以注入模型作为共享服务来代替。</li>
<li>作用域在控制器中被用于向视图绑定模型和封装视图模型（ViewModel），为展示模型的设计模式。</li>
</ul>
<h4 id="scope">Scope</h4>
<p>Treat scope as read-only in templates and write-only in controllers.
The purpose of the scope is to refer to model, not to be the model.
When doing bidirectional binding (ng-model) make sure you don&#39;t bind directly to the scope properties.</p>
<h4 id="-">作用域</h4>
<p>作用域在模板中应该是视为只读的，在控制器中视为只写的。
作用域的目的在于指向模型，而不是成为模型。
当你做双向绑定时（使用<code>ng-model</code>）确定你不要直接绑定到作用域的属性。</p>
<h4 id="model">Model</h4>
<p>Model in AngularJS is a singleton defined by service.
Model provides an excellent way to separate data and display.
Models are prime candidates for unit testing,
as they typically have exactly one dependency (some form of event emitter, in common case the $rootScope)
and contain highly testable domain logic.</p>
<ul>
<li>Model should be considered as an implementation of particular unit.
It is based on single-responsibility-principle.
Unit is an instance that is responsible for its own scope of related logic that may represent single entity in real world
and describe it in programming world in terms of data and state.</li>
<li>Model should encapsulate your application’s data and provide an API to access and manipulate that data.
Model should be portable so it can be easily transported to similar application.</li>
<li>By isolating unit logic in your model you have made it easier to locate, update, and maintain.</li>
<li>Model can use methods of more general global models that are common for the whole application.</li>
<li>Try to avoid composition of other models into your model using dependency injection
if it is not really dependent to decrease components coupling and increase unit testability and usability.</li>
<li>Try to avoid using event listeners in models.
It makes them harder to test and generally kills models in terms of single-responsibility-principle.</li>
</ul>
<h4 id="-">模型</h4>
<p>在AngularJS中模型是一个有服务定义的单例。
模型提供了很好的办法去隔离数据和展示。
模型是进行单元测试的主要对象，因为他们通常只有一个依赖（某种形式的事件发射器，一般情况下为<code>$rootScope</code>）,而且含有高度可测试域的逻辑。</p>
<ul>
<li>模型应当视为特定单元的实现。它基于职责单一原则。
单元是可以反映真实世界中表示单一实体，描述它在程序时间的数据和状态条款，负责自己相关逻辑作用域的一个实例。</li>
<li>模型应该封装应用程序的数据，并提供一个API来访问和操纵数据。模型应该非常便捷，这样它能很容易的运送到类似的应用。</li>
<li>在你的模型中通过隔离单元逻辑，你这一更容易查找、更新和维护。</li>
<li>模型可以使用更多的全局模型的在整个应用程序中公共的方法。</li>
<li>如果它是不是真的依赖性减少部件耦合，增加单元可测试性和可用性，尽量避免其他模型组成到模型中使用依赖注入。</li>
<li>尽量避免使用事件侦听器模型。这使他们难以测试和一般杀死模型的职责单一原则条款。</li>
</ul>
<h4 id="model-implementation">Model Implementation</h4>
<p>As model should encapsulate some logic in terms of data and state,
it should architecturally restrict access to its members thus we can guarantee loose coupling.
The way to do it in AngularJS application is to define it using <code>factory</code> service type.
This will allow us to define private properties and methods very easy
and also return publically accessible ones in single place that will make it really readable for developer.</p>
<h4 id="-">模型实现</h4>
<p>由于模型应该封装一些数据和状态方面的逻辑，它应该架构性的限制访问其成员，这样来保证松耦合。
在AngularJS应用程序中要做到这一点的办法是：使用<code>factory</code>服务类型来定义模型。
这样允许我们很容易的定义私有属性和方法，在一处返回公共访问的开发者真正可读的那一部分。</p>
<pre><code>    angular.module(&#39;search&#39;)
    .factory( &#39;searchModel&#39;, [&#39;searchResource&#39;, function (searchResource) {

      var itemsPerPage = 10,
      currentPage = 1,
      totalPages = 0,
      allLoaded = false,
      searchQuery;

      function init(params) {
        itemsPerPage = params.itemsPerPage || itemsPerPage;
        searchQuery = params.substring || searchQuery;
      }

      function findItems(page, queryParams) {
        searchQuery = queryParams.substring || searchQuery;

        return searchResource.fetch(searchQuery, page, itemsPerPage).then( function (results) {
          totalPages = results.totalPages;
          currentPage = results.currentPage;
          allLoaded = totalPages &lt;= currentPage;

          return results.list
        });
      }

      function findNext() {
        return findItems(currentPage + 1);
      }

      function isAllLoaded() {
        return allLoaded;
      }

      // return public model API
      return {
        /**
         * @param {Object} params
         */
        init: init,

        /**
         * @param {Number} page
         * @param {Object} queryParams
         * @return {Object} promise
         */
        find: findItems,

        /**
         * @return {Boolean}
         */
        allLoaded: isAllLoaded,

        /**
         * @return {Object} promise
         */
        findNext: findNext
      };
    });
</code></pre><h4 id="creating-new-instances">Creating new instances</h4>
<p>Try to avoid having a factory that returns a new able function
as this begins to break down dependency injection
and the library will behave awkwardly, especially for third parties.
A better way to accomplish the same thing is to use the factory
as an API to return a collection of objects with getter and setter methods attached to them.</p>
<h4 id="-">创建一个新的实例</h4>
<p>尽量避免一个工厂返回一个新的可用功能，因为这样开始打破依赖注入和第三方库的笨拙行为。
完成同样事情的更好的办法是：使用工厂作为一个API，返回与连接到他们的getter和setter方法的对象的集合。</p>
<pre><code>angular.module(&#39;car&#39;)
 .factory( &#39;carModel&#39;, [&#39;carResource&#39;, function (carResource) {

  function Car(data) {
    angular.extend(this, data);
  }

  Car.prototype = {
    save: function () {
      // TODO: strip irrelevant fields
      var carData = //...
      return carResource.save(carData);
    }
  };

  function getCarById ( id ) {
    return carResource.getById(id).then(function (data) {
      return new Car(data);
    });
  }

  // the public API
  return {
    // ...
    findById: getCarById
    // ...
  };
});
</code></pre></article></section>    </body>
</html>