<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'/>
    <meta name="description" content="Blog : Qingo" />
    <title>Qingo的博客</title>
</head>
<body>
<h1>$rootScope</h1>

<h2>根作用域服务</h2>

<h3>服务依赖</h3>

<ul><li>$injector</li><li>$exceptionHandler</li><li>$parse</li><li>$browser</li></ul>

<h3>this.$get函数</h3>

<pre><code>this.$get = [&#39;$injector&#39;, &#39;$exceptionHandler&#39;, &#39;$parse&#39;, &#39;$browser&#39;,
    function ($injector, $exceptionHandler, $parse, $browser) {
        return new function Scope() {
                                   this.$id = nextUid();
                                   this.$$phase = this.$parent = this.$$watchers =
                                       this.$$nextSibling = this.$$prevSibling =
                                           this.$$childHead = this.$$childTail = null;
                                   this[&#39;this&#39;] = this.$root = this;
                                   this.$$destroyed = false;
                                   this.$$asyncQueue = [];
                                   this.$$postDigestQueue = [];
                                   this.$$listeners = {};
                                   this.$$listenerCount = {};
                                   this.$$isolateBindings = {};
                               }
}]</code></pre>

<h3>结构</h3>

<pre><code>{
    $id: {{number}},
    $$phase: {{null|}},
    $parent: {{null|Scope}},
    $$watchers: 
        [
            {
                fn: {{Function}},
                last: {{Function}},
                get: {{Function}},
                exp: {{Exp}},
                eq: {{boolean}}
            }
        ],
    $$nextSibling: {{null|Scope}},
    $$prevSibling: {{null|Scope}},
    $$childHead: {{null|Scope}},
    $$childTail: {{null|Scope}},
    $root: {{null|Scope}},
    &#39;this&#39;: {{Scope}},
    $$destroyed: {{boolean}},
    $$asyncQueue: {{Array}},
    $$postDigestQueue: {{Array}},
    $$listeners: {{Object}},
    $$listenerCount: {{Object}},
    $$isolateBindings: {{Object}},
    __proto__:{
        constructor: Scope,
        $new: {{Function}},
        $watch: {{Function}},
        $watchGroup: {{Function}},
        $watchCollection: {{Function}},
        $digest: {{Function}},
        $destroy: {{Function}},
        $eval: {{Function}},
        $evalAsync: {{Function}},
        $$postDigest: {{Function}},
        $apply: {{Function}},
        $on: {{Function}},
        $emit: {{Function}},
        $broadcast: {{Function}}
    }
}</code></pre>

<h3>Scope对象的属性</h3>

<ol><li>$id 
由统一的id生成器 nextUid自动生成，用于标识每个不同的Scope实例</li><li>$$phase
标识该scope正在进行的操作</li><li>$root
根Scope实例</li><li>this</li><li>$parent<br/>用来描述Scope实例间的关系，指向父Scope实例，即：产生此Scope实例的Scope实例，一般使用$new方法来产生</li><li>$nextSibling
用来描述Scope实例间的关系，指向Scope实例的上一个Scope实例。</li><li>$prevSibling
用来描述Scope实例间的关系，指向Scope实例的下一个Scope实例。</li><li>$$childHead</li><li><p>$$childTail</p></li><li><p>$$$watchers
观察者对象</p></li><li><p>$$destroyed</p></li><li>$$asyncQueue</li><li>$$postDigestQueue</li><li>$$listeners</li><li>$$listenerCount</li><li>$$isolateBindings</li></ol>

<h3>Scope对象的方法</h3>

<ol><li>$new
用于创建新的Scope实例，
其中可以传递一个可选的参数<code>isolate</code>,
当<code>isolate</code>为存在时，生成一个没有继承关系的全新的Scope实例，
当<code>isolate</code>不存在时，先产生一个创建子作用域实例的构造方法<code>$$childScopeClass</code>，用于创建新的继承自当前Scope实例的Scope实例，新的Scope实例的<code>$$childScopeClass</code>方法会被覆盖为<code>null</code></li><li>$watch</li><li>$watchCollection</li><li>$digest</li><li>$destroy</li><li>$eval</li><li>$evalAsync</li><li>$$postDigest</li><li>$apply</li><li>$on</li><li>$emit</li><li>$broadcast</li></ol>

<h3>问题</h3>

<p>$watch监听的函数式怎么做的轮询
$$asyncQueue用来缓冲的，那么为什么是$q依赖于$rooScope，而不是$rootScope依赖$q,这样就不需要asyncQueue了。</p>
</body>
</html>