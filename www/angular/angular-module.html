<!DOCTYPE html><html><head><meta charset='utf-8'/><meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no'><title></title><link rel='shortcut icon' href='static/img/q.ico'></head><body><nav></nav><h1 id="module">module</h1>
<p><code>require</code> <a href="https://github.com/angular/angular.js/blob/master/src/loader.js"><code>loader.js</code></a></p>
<h2 id="angular-">angular框架分析之模块</h2>
<p>功能集合
不同的功能集合被封装在不同的模块中，可以通过模块的依赖获取所要使用的功能。</p>
<h3 id="-">模块的作用</h3>
<ul>
<li>通过模块依赖关系，灵活使用各种组件。</li>
<li>为service、animation、filter、controller、directive提供配置接口。</li>
</ul>
<h3 id="angular-module-">angular.module的接口</h3>
<h5 id="-">三个参数</h5>
<ol>
<li><code>name</code>: <code>{String}</code>模块名，后面会直接赋值给模块实例<code>moduleInstance</code>的<code>name</code>属性上。</li>
<li><code>requires</code>: <code>{Array}</code>依赖的模块列表，是以模块名组成的数组。</li>
<li><code>configFn</code>: <code>{Array|Function}</code>配置函数，负责模块的配置，其中具体的配置信息会在使用时被注入。</li>
</ol>
<h5 id="-">调用</h5>
<ol>
<li>生成的模块会被缓存到<code>modules</code>中，如：<br> <code>angular.module(&#39;Qingo&#39;,[]);</code>
 则创建的模块被缓存在<code>modules[&#39;Qingo&#39;]</code>，<code>modules</code>变量是使用闭包，私有化在函数内部的。</li>
<li>当<code>require</code>存在时，此时为创建模块，如果<code>modules</code>中已经缓存了模块，则清楚掉，重新创建。</li>
<li>当<code>require</code>不存在时，此时为获取模块，即从<code>modules</code>中获取出模块，以供执行操作。</li>
</ol>
<h3 id="-angular-module-">模块的结构（angular.module的返回值）</h3>
<pre><code>// 我是伪代码，请不要欺负我。
var moduleInstance = {
    _invokeQueue: {Array},
    _configBlocks: {Array},
    _runBlocks: {Array},
    requires: {Array},
    name: {String},
    provider: {Function},
    factory: {Function},
    service: {Function},
    value: {Function},
    constant: {Function},
    animation: {Function},
    filter: {Function},
    controller: {Function},
    directive: {Function},
    config: {Function},
    run: {Function}
}
</code></pre><h4 id="-">模块的属性</h4>
<ol>
<li><code>_invokeQueue</code>: <code>{Array}</code>调用队列，其中在加载依赖时被调用,其中每一项是一个长度为3的数组，每一项的格式为<br> <code>[provider, method, arguments]</code><br> 第一项<code>provider</code>代表的提供者，第二项<code>method</code>代表的提供者的方法，第三项<code>arguments</code>是提供者执行方法时的参数。</li>
<li><code>_configBlocks</code>: <code>{Array}</code>配置块列表,当定义模块时，第三个参数<code>configFn</code>存在时，<code>config</code>方法被执行，并把相关参数添加到此属性中。具体的格式同<code>_invokeQueue</code>。</li>
<li><code>_runBlocks</code>: <code>{Array}</code>运行块列表</li>
<li><code>requires</code>: <code>{Array}</code>依赖模块列表</li>
<li><code>name</code>: <code>{String}</code>模块名</li>
</ol>
<h4 id="-">模块的方法</h4>
<p>模块的方法是用来操作<code>_invokeQueue</code>、<code>_configBlocks</code>、<code>_runBlocks</code>三个参数使用的，在模块加载时会根据这三个参数中的配置信息来执行不同的操作。</p>
<ol>
<li><code>provider</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;provider&#39;,arguments]</code>。<br> 具体功能参考angular-provider</li>
<li><code>factory</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;factory&#39;,arguments]</code>。</li>
<li><code>service</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;service&#39;,arguments]</code>。</li>
<li><code>value</code>: 向_invokeQueue的开始添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;value&#39;,arguments]</code>。</li>
<li><code>constant</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;constant&#39;,arguments]</code>。</li>
<li><code>animation</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$animationProvider&#39;, &#39;register&#39;,arguments]</code>。</li>
<li><code>filter</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$filterProvider&#39;, &#39;register&#39;,arguments]</code>。</li>
<li><code>controller</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$controllerProvider&#39;, &#39;register&#39;,arguments]</code>。</li>
<li><code>directive</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$compileProvider&#39;, &#39;directive&#39;,arguments]</code>。</li>
<li><code>config</code>: 向_configBlocks中添加一项数据，其添加的数据是一个数组<code>[&#39;$injector&#39;, &#39;invoke&#39;,arguments]</code>。</li>
<li><code>run</code>: 向_runBlocks中添加一项数据，其添加的一个<code>block</code>。</li>
</ol>
<h3 id="-">源码使用参考</h3>
<p><code>require</code> <a href="https://github.com/angular/angular.js/blob/master/src/AngularPublic.js"><code>AngularPublic.js</code></a></p>
<pre><code>angularModule = setupModuleLoader(window);
</code></pre><p>其中<code>setupModuleLoader</code>的返回值为<code>angular.module</code>，即<code>angularModule === angular.module</code></p>
<pre><code>try {
    angularModule(&#39;ngLocale&#39;);
} catch (e) {
    angularModule(&#39;ngLocale&#39;, []).provider (&#39;$locale&#39;, $LocaleProvider);
}
</code></pre><p>因为<code>ng</code>模块依赖<code>ngLocale</code>模块，所以先创建<code>ngLocale</code>模块，再创建<code>ng</code>模块。</p>
<pre><code>angularModule(&#39;ng&#39;, [&#39;ngLocale&#39;], [&#39;$provide&#39;,
        function ngModule($provide) {
            // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.
            $provide.provider({
                $$sanitizeUri: $$SanitizeUriProvider
            });
            $provide.provider(&#39;$compile&#39;, $CompileProvider).
                directive({
                    a: htmlAnchorDirective,
                    .
                    .此处省略x个字
                    .
                    ngModelOptions: ngModelOptionsDirective
                }).
                directive({
                    ngInclude: ngIncludeFillContentDirective
                }).
                directive(ngAttributeAliasDirectives).
                directive(ngEventDirectives);
            $provide.provider({
                $anchorScroll: $AnchorScrollProvider,
                .
                .此处省略x个字
                .
                $$asyncCallback: $$AsyncCallbackProvider
            });
        }
    ]);
</code></pre><p>先获取<code>ngLocale</code>模块,如果没有获取到，会跳转到<code>catch</code>语句中创建<code>ngLocale</code>模块。在上面的代码中，<code>ngLocale</code>模块的创建没有第三个参数配置函数<code>configFn</code>，在创建了模块之后，添加了一个提供者<code>provider</code>。
所以现在<code>ngLocale</code>模块的结构为：</p>
<pre><code>{
    _invokeQueue: [&#39;$provider&#39;, &#39;provide&#39;, [&#39;$locale&#39;, $LocaleProvider]],
    _configBlocks: [],
    _runBlocks: [],
    requires: [],
    name: &#39;ngLocate&#39;,
    ...原始模块的方法（factory、factory等）
}
</code></pre><p>创建<code>ng</code>模块，其依赖<code>ngLocale</code>模块，有配置函数，所有限制<code>ng</code>模块的结构为：</p>
<pre><code>{
    _invokeQueue: [],
    _configBlocks: [&#39;$injector&#39;, &#39;invoke&#39;, [&#39;$provide&#39;, function ngModule($provide) { ... }]],
    _runBlocks: [],
    requires: [&#39;$locale&#39;],
    name: &#39;ng&#39;,
    ...原始模块的方法（factory、factory等）
}
</code></pre><p>其中<code>ng</code>模块的配置函数式直接执行提供者，在配置函数内部执行添加提供者操作和添加指令操作，其实和获取<code>ng</code>模块后调用<code>provider</code>、<code>directive</code>等方法、是等价的，
配置函数做了一个快捷配置的操作。</p>
<h3 id="-">组件源码使用参考</h3>
<p><code>require</code> <a href="https://github.com/angular/bower-angular-route/blob/master/angular-route.js"><code>angular-route</code></a>  </p>
<pre><code>var ngRouteModule = angular.module(&#39;ngRoute&#39;, [&#39;ng&#39;]).
                        provider(&#39;$route&#39;, $RouteProvider);
</code></pre><h3 id="-module">自定义module</h3>
<pre><code>angular.module(&#39;Qingo&#39;,[&#39;ng&#39;, &#39;ngRoute&#39;], function(){...});
angular.module(&#39;Qingo&#39;).provider(&#39;QTestProvider&#39;,function(){...});
</code></pre><p>创建<code>Qingo</code>模块，它依赖于<code>ng</code>、<code>ngRoute</code>，然后给<code>Qingo</code>模块上添加了一个<code>QTestProvider</code>提供者。</p>
</body></html>