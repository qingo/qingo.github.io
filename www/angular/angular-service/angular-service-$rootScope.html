<!DOCTYPE html>
<html>
<head lang="en">
  <meta charset="UTF-8">
  <meta name='viewport' content='width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no'>
  <link rel='shortcut icon' href='/img/q.ico'>
  <title>Qingo'blog|小前端真不小</title>
  <link rel="stylesheet" href="/bower_components/elyts/dist/minified/css/elyts.css"/>
</head>
<body><section class="container"><article><h1 id="-rootscope">$rootScope</h1>
<h2 id="-">根作用域服务</h2>
<h3 id="-">服务依赖</h3>
<ul>
<li>$injector</li>
<li>$exceptionHandler</li>
<li>$parse</li>
<li>$browser<h3 id="this-get-">this.$get函数</h3>
</li>
</ul>
<pre><code>this.$get = [&#39;$injector&#39;, &#39;$exceptionHandler&#39;, &#39;$parse&#39;, &#39;$browser&#39;,
    function ($injector, $exceptionHandler, $parse, $browser) {
        return new function Scope() {
                                   this.$id = nextUid();
                                   this.$$phase = this.$parent = this.$$watchers =
                                       this.$$nextSibling = this.$$prevSibling =
                                           this.$$childHead = this.$$childTail = null;
                                   this[&#39;this&#39;] = this.$root = this;
                                   this.$$destroyed = false;
                                   this.$$asyncQueue = [];
                                   this.$$postDigestQueue = [];
                                   this.$$listeners = {};
                                   this.$$listenerCount = {};
                                   this.$$isolateBindings = {};
                               }
}]
</code></pre><h3 id="-">结构</h3>
<pre><code>{
    $id: {{number}},
    $$phase: {{null|}},
    $parent: {{null|Scope}},
    $$watchers: 
        [
            {
                fn: {{Function}},
                last: {{Function}},
                get: {{Function}},
                exp: {{Exp}},
                eq: {{boolean}}
            }
        ],
    $$nextSibling: {{null|Scope}},
    $$prevSibling: {{null|Scope}},
    $$childHead: {{null|Scope}},
    $$childTail: {{null|Scope}},
    $root: {{null|Scope}},
    &#39;this&#39;: {{Scope}},
    $$destroyed: {{boolean}},
    $$asyncQueue: {{Array}},
    $$postDigestQueue: {{Array}},
    $$listeners: {{Object}},
    $$listenerCount: {{Object}},
    $$isolateBindings: {{Object}},
    __proto__:{
        constructor: Scope,
        $new: {{Function}},
        $watch: {{Function}},
        $watchGroup: {{Function}},
        $watchCollection: {{Function}},
        $digest: {{Function}},
        $destroy: {{Function}},
        $eval: {{Function}},
        $evalAsync: {{Function}},
        $$postDigest: {{Function}},
        $apply: {{Function}},
        $on: {{Function}},
        $emit: {{Function}},
        $broadcast: {{Function}}
    }
}
</code></pre><h3 id="scope-">Scope对象的属性</h3>
<ol>
<li>$id 
 由统一的id生成器 nextUid自动生成，用于标识每个不同的Scope实例</li>
<li>$$phase
 标识该scope正在进行的操作</li>
<li>$root
 根Scope实例</li>
<li>this
 Scope实例本身。</li>
<li>$parent<br> 用来描述Scope实例间的关系，指向父Scope实例，即：产生此Scope实例的Scope实例，一般使用$new方法来产生</li>
<li>$$nextSibling
 用来描述Scope实例间兄弟的关系，指向Scope实例的上一个兄弟Scope实例。</li>
<li>$$prevSibling
 用来描述Scope实例间兄弟的关系，指向Scope实例的下一个兄弟Scope实例。</li>
<li>$$childHead
 用来描述Scope实例间子Scope实例的关系，指向Scope实例的下一个子Scope实例中的第一个，主要用来维护子Scope实例的兄弟关系。</li>
<li>$$childTail
 用来描述Scope实例间子Scope实例的关系，指向Scope实例的下一个子Scope实例中的最后一个，主要用来维护子Scope实例的兄弟关系。</li>
<li>$$$watchers
观察者属性</li>
</ol>
<ol>
<li>$$destroyed</li>
<li>$$asyncQueue</li>
<li>$$postDigestQueue</li>
<li>$$listeners
监听者属性</li>
<li>$$listenerCount</li>
<li>$$isolateBindings<h3 id="scope-">Scope对象的方法</h3>
</li>
<li>$new
 用于创建新的Scope实例，其中可以传递一个可选的参数<code>isolate</code>,
 创建过程可以分为两步；<br> 第一步：创建新的Scope实例，其中<ol>
<li>当<code>isolate</code>为存在时，生成一个没有继承关系的全新的Scope实例，</li>
<li>当<code>isolate</code>不存在时，先产生一个创建子作用域实例的构造方法<code>$$childScopeClass</code>，用于创建新的继承自当前Scope实例的Scope实例，新的Scope实例的<code>$$childScopeClass</code>方法会被覆盖为<code>null</code><br>第二步：维护Scope实例的关系
不管<code>isolate</code>为<code>true</code>或<code>false</code>新创建的Scope实例都会被追加到子Scope的尾部，即$$childTail上，并维护好子Scope实例的兄弟关系。</li>
</ol>
</li>
<li><p>$watch</p>
</li>
<li><p>$watchCollection</p>
</li>
<li>$digest</li>
<li>$destroy</li>
<li>$eval</li>
<li>$evalAsync</li>
<li>$$postDigest</li>
<li>$apply</li>
<li>$on</li>
<li>$emit</li>
<li>$broadcast</li>
</ol>
<h3 id="-">问题</h3>
<p>$watch监听的函数式怎么做的轮询
$$asyncQueue用来缓冲的，那么为什么是$q依赖于$rooScope，而不是$rootScope依赖$q,这样就不需要asyncQueue了。</p>
</article></section>    </body>
</html>