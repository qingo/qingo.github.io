{"JavaScript-base/_":{"releaseTime":"2014-12-06T05:11:58.000Z","refreshTime":"2014-12-06T06:29:57.000Z","url":"JavaScript-base/_","contents":"<p>啦啦啦啦</p>\n"},"JavaScript-base/lexer":{"releaseTime":"2014-07-17T10:29:10.000Z","refreshTime":"2014-12-02T03:03:45.000Z","url":"JavaScript-base/lexer","contents":"<h1 id=\"-lexer-\">词法分析(lexer)</h1>\n<h2 id=\"ecma262-\">ecma262、犀牛书第二章读后感</h2>\n<p>编程语言的词法结构是一套基础性规律，用来描述如何使用这门语言来编写程序。作为语法的基础，它规定了诸如变量名是什么样的，怎么写注释，以及程序语言直接如何分隔等规律。</p>\n<h2 id=\"-\">词法分析器的作用：</h2>\n<ol>\n<li>把字符串从前到后划分为某种语言的执行循序的各个组成部分<h2 id=\"lexer-\">lexer实例分析</h2>\n<h3 id=\"angular-parse-lexer-\">angular-parse中的lexer部分</h3>\nLexer类的原型上有一个分词方法叫做lex，在lex中，用循环来分析一个字符串，\n分别来判断字符串是不是为字符串、数字、标识符、部分操作符（&#39;(&#39;、&#39;)&#39;、&#39;{&#39;、&#39;}&#39;、&#39;[&#39;、&#39;]&#39;、&#39;.&#39;、&#39;,&#39;、&#39;;&#39;、&#39;:&#39;、&#39;?&#39;）、\n空白符、剩余的操作符（&#39;null&#39;、&#39;true&#39;、&#39;false&#39;、&#39;undefined&#39;、&#39;+&#39;、&#39;-&#39;、&#39;*&#39;、&#39;/&#39;、&#39;%&#39;、&#39;^&#39;、&#39;=&#39;、&#39;===&#39;、&#39;!==&#39;、&#39;==&#39;、&#39;!=&#39;、&#39;&lt;&#39;、&#39;&gt;&#39;、&#39;&lt;=&#39;、&#39;&amp;&amp;&#39;、&#39;||&#39;、&#39;&amp;&#39;、&#39;|&#39;、&#39;!&#39;）及其不支持字符报出异常。</li>\n</ol>\n"},"angular/Understanding design pattern":{"releaseTime":"2015-01-05T02:54:58.000Z","refreshTime":"2015-01-05T09:22:39.000Z","url":"angular/Understanding design pattern","contents":"<h3 id=\"angularjs-understanding-design-pattern\">AngularJS: Understanding design pattern</h3>\n<p>MVC vs MVVM vs MVP.\nWhat a controversial topic that many developers can spend hours and hours debating and arguing about.\nFor several years AngularJS was closer to MVC (or rather one of its client-side variants),\nbut over time and thanks to many refactorings and api improvements,\nit&#39;s now closer to MVVM – the $scope object could be considered the ViewModel that is being decorated by a function that we call a Controller.\nBeing able to categorize a framework and put it into one of the MV<em> buckets has some advantages.\nIt can help developers get more comfortable with its apis by making it easier to create a mental model that represents the application that is being built with the framework.\nIt can also help to establish terminology that is used by developers.\nHaving said, I&#39;d rather see developers build kick-ass apps that are well-designed and follow separation of concerns,\nthan see them waste time arguing about MV</em> nonsense.\nAnd for this reason, I hereby declare AngularJS to be MVW framework - Model-View-Whatever.\nWhere Whatever stands for &quot;whatever works for you&quot;.\nAngular gives you a lot of flexibility to nicely separate presentation logic from business logic and presentation state.\nPlease use it fuel your productivity and application maintainability rather than heated discussions about things that at the end of the day don&#39;t matter that much.</p>\n<h3 id=\"angularjs-\">AngularJS: 理解设计模式</h3>\n<p>MVC vs MVVM vs MVP\n这是一个很多开发者都愿意花几个小时去争论和商议的有争议的问题。\n几年来<code>AngularJS</code>接近<code>MVC</code>（或者更确切的说是一个客户端的变体），\n但是随着时间的推移，感谢很多的重构和API的改善，\n它更接近于<code>MVVM</code>-<code>$scope</code>对象被认为是有一个叫做<code>Controller</code>修饰的<code>ViewModel</code>。\n能够分类一个框架，将其放入<code>MV*</code>之中是有一些好处的。\n能够帮助开发者更加舒服的使用它的api，更加轻松的创建基于框架的应用程序的心理模型。\n还有助于创建开发者使用的术语。\n尽管如此，相对于看到他们浪费时间去争论<code>MV*</code>的无稽之谈，我更愿意看到开发者创建良好设计的并遵循关注点分离的“踢屁股”应用。\n基于这个原因，本人特此声明，<code>AngularJS</code>是<code>MVW框架</code>-<code>Model-View-Whatever</code>。\n其中<code>Whatever</code>代表“无论你做什么”。\nAngular给于你很大的灵活性去更好的分离从业务逻辑到表现状态的表现逻辑。\n请使用它促进你的生产效率和应用程序的可维护性，而不是成天到晚做一些不重要的争论。</p>\n<h3 id=\"thanks-to-a-huge-amount-of-valuable-sources-i-ve-got-some-general-recommendations-for-implementing-components-in-angularjs-apps-\">Thanks to a huge amount of valuable sources I&#39;ve got some general recommendations for implementing components in AngularJS apps:</h3>\n<h3 id=\"-angularjs-\">感谢大量的宝贵的来源，我已经有一些在AngularJS应用中实现组建的通用性建议：</h3>\n<h4 id=\"controller\">Controller</h4>\n<ul>\n<li>Controller should be just an interlayer between model and view.\nTry to make it as thin as possible.</li>\n<li>It is highly recommended to avoid business logic in controller.\nIt should be moved to model.</li>\n<li>Controller may communicate with other controllers using method invocation\n(possible when children wants to communicate with parent) or $emit, $broadcast and $on methods.\nThe emitted and broadcasted messages should be kept to a minimum.</li>\n<li>Controller should not care about presentation or DOM manipulation.</li>\n<li>Try to avoid nested controllers.\nIn this case parent controller is interpreted as model.\nInject models as shared services instead.</li>\n<li>Scope in controller should be used for binding model with view and\nencapsulating View Model as for Presentation Model design pattern.</li>\n</ul>\n<h4 id=\"-controller-\">控制器（Controller）</h4>\n<ul>\n<li>控制器应该仅仅是模型和试图的中间层，使其尽可能地薄。</li>\n<li>强烈建议在控制器中避免业务逻辑，它应该被转移到模型中。</li>\n<li>控制器可以使用方法调用与其他控制器进行通讯（可能是当孩子想和父母沟通时），或者<code>$emit</code>、<code>$broadcast</code>、<code>$on</code>方法。</li>\n<li>控制器不关心展现或者DOM操作。</li>\n<li>尽可能的避免嵌套作用域。在这种情况下父控制器被解释为模型，可以注入模型作为共享服务来代替。</li>\n<li>作用域在控制器中被用于向视图绑定模型和封装视图模型（ViewModel），为展示模型的设计模式。</li>\n</ul>\n<h4 id=\"scope\">Scope</h4>\n<p>Treat scope as read-only in templates and write-only in controllers.\nThe purpose of the scope is to refer to model, not to be the model.\nWhen doing bidirectional binding (ng-model) make sure you don&#39;t bind directly to the scope properties.</p>\n<h4 id=\"-\">作用域</h4>\n<p>作用域在模板中应该是视为只读的，在控制器中视为只写的。\n作用域的目的在于指向模型，而不是成为模型。\n当你做双向绑定时（使用<code>ng-model</code>）确定你不要直接绑定到作用域的属性。</p>\n<h4 id=\"model\">Model</h4>\n<p>Model in AngularJS is a singleton defined by service.\nModel provides an excellent way to separate data and display.\nModels are prime candidates for unit testing,\nas they typically have exactly one dependency (some form of event emitter, in common case the $rootScope)\nand contain highly testable domain logic.</p>\n<ul>\n<li>Model should be considered as an implementation of particular unit.\nIt is based on single-responsibility-principle.\nUnit is an instance that is responsible for its own scope of related logic that may represent single entity in real world\nand describe it in programming world in terms of data and state.</li>\n<li>Model should encapsulate your application’s data and provide an API to access and manipulate that data.\nModel should be portable so it can be easily transported to similar application.</li>\n<li>By isolating unit logic in your model you have made it easier to locate, update, and maintain.</li>\n<li>Model can use methods of more general global models that are common for the whole application.</li>\n<li>Try to avoid composition of other models into your model using dependency injection\nif it is not really dependent to decrease components coupling and increase unit testability and usability.</li>\n<li>Try to avoid using event listeners in models.\nIt makes them harder to test and generally kills models in terms of single-responsibility-principle.</li>\n</ul>\n<h4 id=\"-\">模型</h4>\n<p>在AngularJS中模型是一个有服务定义的单例。\n模型提供了很好的办法去隔离数据和展示。\n模型是进行单元测试的主要对象，因为他们通常只有一个依赖（某种形式的事件发射器，一般情况下为<code>$rootScope</code>）,而且含有高度可测试域的逻辑。</p>\n<ul>\n<li>模型应当视为特定单元的实现。它基于职责单一原则。\n单元是可以反映真实世界中表示单一实体，描述它在程序时间的数据和状态条款，负责自己相关逻辑作用域的一个实例。</li>\n<li>模型应该封装应用程序的数据，并提供一个API来访问和操纵数据。模型应该非常便捷，这样它能很容易的运送到类似的应用。</li>\n<li>在你的模型中通过隔离单元逻辑，你这一更容易查找、更新和维护。</li>\n<li>模型可以使用更多的全局模型的在整个应用程序中公共的方法。</li>\n<li>如果它是不是真的依赖性减少部件耦合，增加单元可测试性和可用性，尽量避免其他模型组成到模型中使用依赖注入。</li>\n<li>尽量避免使用事件侦听器模型。这使他们难以测试和一般杀死模型的职责单一原则条款。</li>\n</ul>\n"},"angular/angular-bootstrap":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-bootstrap","contents":"<h1 id=\"bootstrap\">bootstrap</h1>\n<h2 id=\"angular-\">angular框架分析之启动程序</h2>\n<p>angular是以HTML风格的模板为基础，其ng-app（ng:app、x-ng-app、data-ng-app）为模板入口，也是angular程序执行的入口，\n从ng-app开始的HTML被视为angular的模板，其内部的扩展指令会根据angular不同模块中配置的指令，发挥其扩展的功能。</p>\n"},"angular/angular-directive":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-directive","contents":"<h1 id=\"directive\">directive</h1>\n<h2 id=\"angular-\">angular框架分析之指令</h2>\n"},"angular/angular-injector":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-injector","contents":"<h1 id=\"injector\">injector</h1>\n<h2 id=\"angular-\">angular框架分析之注入器</h2>\n"},"angular/angular-module":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-module","contents":"<h1 id=\"module\">module</h1>\n<p><code>require</code> <a href=\"https://github.com/angular/angular.js/blob/master/src/loader.js\"><code>loader.js</code></a></p>\n<h2 id=\"angular-\">angular框架分析之模块</h2>\n<p>功能集合\n不同的功能集合被封装在不同的模块中，可以通过模块的依赖获取所要使用的功能。</p>\n<h3 id=\"-\">模块的作用</h3>\n<ul>\n<li>通过模块依赖关系，灵活使用各种组件。</li>\n<li>为service、animation、filter、controller、directive提供配置接口。</li>\n</ul>\n<h3 id=\"angular-module-\">angular.module的接口</h3>\n<h5 id=\"-\">三个参数</h5>\n<ol>\n<li><code>name</code>: <code>{String}</code>模块名，后面会直接赋值给模块实例<code>moduleInstance</code>的<code>name</code>属性上。</li>\n<li><code>requires</code>: <code>{Array}</code>依赖的模块列表，是以模块名组成的数组。</li>\n<li><code>configFn</code>: <code>{Array|Function}</code>配置函数，负责模块的配置，其中具体的配置信息会在使用时被注入。</li>\n</ol>\n<h5 id=\"-\">调用</h5>\n<ol>\n<li>生成的模块会被缓存到<code>modules</code>中，如：<br> <code>angular.module(&#39;Qingo&#39;,[]);</code>\n 则创建的模块被缓存在<code>modules[&#39;Qingo&#39;]</code>，<code>modules</code>变量是使用闭包，私有化在函数内部的。</li>\n<li>当<code>require</code>存在时，此时为创建模块，如果<code>modules</code>中已经缓存了模块，则清楚掉，重新创建。</li>\n<li>当<code>require</code>不存在时，此时为获取模块，即从<code>modules</code>中获取出模块，以供执行操作。</li>\n</ol>\n<h3 id=\"-angular-module-\">模块的结构（angular.module的返回值）</h3>\n<pre><code>// 我是伪代码，请不要欺负我。\nvar moduleInstance = {\n    _invokeQueue: {Array},\n    _configBlocks: {Array},\n    _runBlocks: {Array},\n    requires: {Array},\n    name: {String},\n    provider: {Function},\n    factory: {Function},\n    service: {Function},\n    value: {Function},\n    constant: {Function},\n    animation: {Function},\n    filter: {Function},\n    controller: {Function},\n    directive: {Function},\n    config: {Function},\n    run: {Function}\n}\n</code></pre><h4 id=\"-\">模块的属性</h4>\n<ol>\n<li><code>_invokeQueue</code>: <code>{Array}</code>调用队列，其中在加载依赖时被调用,其中每一项是一个长度为3的数组，每一项的格式为<br> <code>[provider, method, arguments]</code><br> 第一项<code>provider</code>代表的提供者，第二项<code>method</code>代表的提供者的方法，第三项<code>arguments</code>是提供者执行方法时的参数。</li>\n<li><code>_configBlocks</code>: <code>{Array}</code>配置块列表,当定义模块时，第三个参数<code>configFn</code>存在时，<code>config</code>方法被执行，并把相关参数添加到此属性中。具体的格式同<code>_invokeQueue</code>。</li>\n<li><code>_runBlocks</code>: <code>{Array}</code>运行块列表</li>\n<li><code>requires</code>: <code>{Array}</code>依赖模块列表</li>\n<li><code>name</code>: <code>{String}</code>模块名</li>\n</ol>\n<h4 id=\"-\">模块的方法</h4>\n<p>模块的方法是用来操作<code>_invokeQueue</code>、<code>_configBlocks</code>、<code>_runBlocks</code>三个参数使用的，在模块加载时会根据这三个参数中的配置信息来执行不同的操作。</p>\n<ol>\n<li><code>provider</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;provider&#39;,arguments]</code>。<br> 具体功能参考angular-provider</li>\n<li><code>factory</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;factory&#39;,arguments]</code>。</li>\n<li><code>service</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;service&#39;,arguments]</code>。</li>\n<li><code>value</code>: 向_invokeQueue的开始添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;value&#39;,arguments]</code>。</li>\n<li><code>constant</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$provider&#39;, &#39;constant&#39;,arguments]</code>。</li>\n<li><code>animation</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$animationProvider&#39;, &#39;register&#39;,arguments]</code>。</li>\n<li><code>filter</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$filterProvider&#39;, &#39;register&#39;,arguments]</code>。</li>\n<li><code>controller</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$controllerProvider&#39;, &#39;register&#39;,arguments]</code>。</li>\n<li><code>directive</code>: 向_invokeQueue中添加一项数据，其添加的数据是一个数组<code>[&#39;$compileProvider&#39;, &#39;directive&#39;,arguments]</code>。</li>\n<li><code>config</code>: 向_configBlocks中添加一项数据，其添加的数据是一个数组<code>[&#39;$injector&#39;, &#39;invoke&#39;,arguments]</code>。</li>\n<li><code>run</code>: 向_runBlocks中添加一项数据，其添加的一个<code>block</code>。</li>\n</ol>\n<h3 id=\"-\">源码使用参考</h3>\n<p><code>require</code> <a href=\"https://github.com/angular/angular.js/blob/master/src/AngularPublic.js\"><code>AngularPublic.js</code></a></p>\n<pre><code>angularModule = setupModuleLoader(window);\n</code></pre><p>其中<code>setupModuleLoader</code>的返回值为<code>angular.module</code>，即<code>angularModule === angular.module</code></p>\n<pre><code>try {\n    angularModule(&#39;ngLocale&#39;);\n} catch (e) {\n    angularModule(&#39;ngLocale&#39;, []).provider (&#39;$locale&#39;, $LocaleProvider);\n}\n</code></pre><p>因为<code>ng</code>模块依赖<code>ngLocale</code>模块，所以先创建<code>ngLocale</code>模块，再创建<code>ng</code>模块。</p>\n<pre><code>angularModule(&#39;ng&#39;, [&#39;ngLocale&#39;], [&#39;$provide&#39;,\n        function ngModule($provide) {\n            // $$sanitizeUriProvider needs to be before $compileProvider as it is used by it.\n            $provide.provider({\n                $$sanitizeUri: $$SanitizeUriProvider\n            });\n            $provide.provider(&#39;$compile&#39;, $CompileProvider).\n                directive({\n                    a: htmlAnchorDirective,\n                    .\n                    .此处省略x个字\n                    .\n                    ngModelOptions: ngModelOptionsDirective\n                }).\n                directive({\n                    ngInclude: ngIncludeFillContentDirective\n                }).\n                directive(ngAttributeAliasDirectives).\n                directive(ngEventDirectives);\n            $provide.provider({\n                $anchorScroll: $AnchorScrollProvider,\n                .\n                .此处省略x个字\n                .\n                $$asyncCallback: $$AsyncCallbackProvider\n            });\n        }\n    ]);\n</code></pre><p>先获取<code>ngLocale</code>模块,如果没有获取到，会跳转到<code>catch</code>语句中创建<code>ngLocale</code>模块。在上面的代码中，<code>ngLocale</code>模块的创建没有第三个参数配置函数<code>configFn</code>，在创建了模块之后，添加了一个提供者<code>provider</code>。\n所以现在<code>ngLocale</code>模块的结构为：</p>\n<pre><code>{\n    _invokeQueue: [&#39;$provider&#39;, &#39;provide&#39;, [&#39;$locale&#39;, $LocaleProvider]],\n    _configBlocks: [],\n    _runBlocks: [],\n    requires: [],\n    name: &#39;ngLocate&#39;,\n    ...原始模块的方法（factory、factory等）\n}\n</code></pre><p>创建<code>ng</code>模块，其依赖<code>ngLocale</code>模块，有配置函数，所有限制<code>ng</code>模块的结构为：</p>\n<pre><code>{\n    _invokeQueue: [],\n    _configBlocks: [&#39;$injector&#39;, &#39;invoke&#39;, [&#39;$provide&#39;, function ngModule($provide) { ... }]],\n    _runBlocks: [],\n    requires: [&#39;$locale&#39;],\n    name: &#39;ng&#39;,\n    ...原始模块的方法（factory、factory等）\n}\n</code></pre><p>其中<code>ng</code>模块的配置函数式直接执行提供者，在配置函数内部执行添加提供者操作和添加指令操作，其实和获取<code>ng</code>模块后调用<code>provider</code>、<code>directive</code>等方法、是等价的，\n配置函数做了一个快捷配置的操作。</p>\n<h3 id=\"-\">组件源码使用参考</h3>\n<p><code>require</code> <a href=\"https://github.com/angular/bower-angular-route/blob/master/angular-route.js\"><code>angular-route</code></a>  </p>\n<pre><code>var ngRouteModule = angular.module(&#39;ngRoute&#39;, [&#39;ng&#39;]).\n                        provider(&#39;$route&#39;, $RouteProvider);\n</code></pre><h3 id=\"-module\">自定义module</h3>\n<pre><code>angular.module(&#39;Qingo&#39;,[&#39;ng&#39;, &#39;ngRoute&#39;], function(){...});\nangular.module(&#39;Qingo&#39;).provider(&#39;QTestProvider&#39;,function(){...});\n</code></pre><p>创建<code>Qingo</code>模块，它依赖于<code>ng</code>、<code>ngRoute</code>，然后给<code>Qingo</code>模块上添加了一个<code>QTestProvider</code>提供者。</p>\n"},"angular/angular-overview":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-overview","contents":"<h1 id=\"overview\">overview</h1>\n<h2 id=\"angular-\">angular框架分析之框架概述</h2>\n<p>angular是一个非常完备的框架，其表现在：</p>\n<ul>\n<li>对JavaScript语言使用的独特风格。</li>\n<li>怎么使用（只需要写什么）？</li>\n<li>机制</li>\n</ul>\n<h3 id=\"-javascript-\">对JavaScript语言使用的独特风格。</h3>\n<p>比如：jQuery的链式调用、getter和setter共用一个函数等。\n而在angular中，又有什么样的风格呢</p>\n<ol>\n<li>angular以HTML风格的模板为基础，用JavaScript实现的指令（directive）来扩充HTML的元素（Element）、属性（Attribute）、注释节点（Comment）、类（Class）、文字节点（TextNode）的表现力，\n用scope来管理JavaScript的作用域与数据绑定，用controller来管理业务逻辑。</li>\n<li>命名空间</li>\n<li>数组和函数式等价的函数表达方式</li>\n<li>函数实参的传递</li>\n<li>函数的定义</li>\n</ol>\n<p>angular的依赖关系是改变函数的调用方式来解决依赖的，\n首先查找要执行的函数形参，根据形参的字符串值来获取相应的服务（或提供者），\n把获取到的服务(或提供者)指定为函数调用的参数，使其和形参中的参数一一对应，从而在函数内部依赖的服务（或提供者）能够保障被使用，从来解决的依赖调用，\n而把获取相应的参数并调用函数的过着称作为“依赖注入”。\n依赖注入依靠的是注入器（injector），\n注入器（injector），函数调用和函数实例化的接口，有两种不同的注入器，其一种是用来解决提供者依赖注入的，当依赖的提供者不存在时，就直接抛出异常，\n另一种注入器是用来解决服务（service）依赖注入的，当依赖的服务不存在时，就在提供者中调用其配置函数，并把生成的服务注入的依赖参数中，\nprovider为用于注入某个功能的配置对象，\n模块module包含多个provider的配置函数，用过注入器（providerCache.injector）调用配置函数，返回注入器（provider）\nprovider为service提供配置函数（$get），通过注入器（instanceCache.injector）调用配置函数，返回服务（service）</p>\n<p>module是不同功能配置对象的集合，\n而service是一个具体的功能块，</p>\n"},"angular/angular-provider-$provider":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-provider-$provider","contents":"<h3 id=\"-provider-\">$provider提供者</h3>\n<pre><code>$provide: {\n    provider: {Function},\n    factory: {Function},\n    service: {Function},\n    value: {Function},\n    constant: {Function},\n    decorator: {Function}\n}\n</code></pre>"},"angular/angular-provider":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-provider","contents":"<h1 id=\"provider\">provider</h1>\n<p><code>require</code> <a href=\"https://github.com/angular/angular.js/blob/master/src/auto/injector.js\"><code>injector.js</code></a></p>\n<h2 id=\"angular-\">angular框架分析之提供者</h2>\n<h3 id=\"-\">提供者的功能</h3>\n<ol>\n<li>为模块（module）的功能，提供缓存数据。\n所以的提供者（provider）都被缓存在providerCache中，而providerCache被闭包私有化在了函数内部。</li>\n<li>为服务（service）缓存配置函数（具体在其this.$get函数中）,一边注入器根据配置函数生成服务。</li>\n<li>某些提供者为模块（module）提供功能接口：\n在module的_invokeQueue、_configBlocks和_runBlocks属性中存在的所以配置相关数据，都会被相应的提供者调用。</li>\n</ol>\n<h3 id=\"ng-\">ng模块中提供的提供者</h3>\n<h5 id=\"-\">两个原始的提供者</h5>\n<ul>\n<li>$provider： 将其他提供者添加到提供者缓存对象中。</li>\n<li>$injector： 注入提供者，基本点函数调用</li>\n</ul>\n<pre><code>providerCache: {\n    $provider: {Object},\n    $injector: {Object}\n}\nproviderCache: {\n    $provider: {Object},\n    $injector: {Object},\n    $CompileProvider: {Object},\n    $AnchorScrollProvider: {Object},\n    $BrowserProvider: {Object},\n    $CacheFactoryProvider: {Object},\n    $ControllerProvider: {Object},\n    $DocumentProvider: {Object},\n    $ExceptionHandlerProvider: {Object},\n    $FilterProvider: {Object},\n    $InterpolateProvider: {Object},\n    $IntervalProvider: {Object},\n    $HttpProvider: {Object},\n    $HttpBackendProvider: {Object},\n    $LocationProvider: {Object},\n    $LogProvider: {Object},\n    $ParseProvider: {Object},\n    $RootScopeProvider: {Object},\n    $QProvider: {Object},\n    $SceProvider: {Object},\n    $SceDelegateProvider: {Object},\n    $SnifferProvider: {Object},\n    $TemplateCacheProvider: {Object},\n    $TimeoutProvider: {Object},\n    $WindowProvider: {Object},\n    $$RAFProvider: {Object},\n    $$AsyncCallbackProvider: {Object}\n}\n</code></pre><h5 id=\"-\">为模块提供功能的提供者</h5>\n<ul>\n<li>$compileProvider的directive方法用来添加指令（directive）。</li>\n<li>$filterProvider的register方法用来添加过滤器（filter）。</li>\n<li>$controllerProvider的register方法添加控制器（controller）。</li>\n<li>$animationProvider的register方法添加动画（animation）。<h5 id=\"-\">其他提供者</h5>\n</li>\n</ul>\n"},"angular/jQuery2angular":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/jQuery2angular","contents":""},"angular/module-service":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/module-service","contents":"<h1 id=\"service\">service</h1>\n<h2 id=\"angular-\">angular框架分析之服务</h2>\n<p>module是不同功能的集合，而service是具体某个功能，\n作为函数调用的参数传入的函数内，一共使用</p>\n"},"ecma262_5_1/15_9 Date Objects 日期对象(翻译)":{"releaseTime":"2014-12-12T02:36:15.000Z","refreshTime":"2014-12-13T14:48:37.000Z","url":"ecma262_5_1/15_9 Date Objects 日期对象(翻译)","contents":"<h1 id=\"date-objects\">Date Objects</h1>\n<h1 id=\"-\">日期对象</h1>\n<h2 id=\"overview-of-date-objects-and-definitions-of-abstract-operators\">Overview of Date Objects and Definitions of Abstract Operators</h2>\n<p>The following functions are abstract operations that operate on time values\n(defined in 15.9.1.1). Note that, in every case, if any argument to one of these functions is NaN,\nthe result will be NaN.</p>\n<h2 id=\"-\">概述日期对象和抽象的操作者的定义</h2>\n<p>下面的函数是操作日期值（在15.9.1.1中定义的）的抽象操作。\n注意：在每种场景中，如果某一个函数中的任意参数为NaN，那么结果也将为NaN.</p>\n<h3 id=\"time-values-and-time-range\">Time Values and Time Range</h3>\n<p>A Date object contains a Number indicating a particular instant in time to within a millisecond.\nSuch a Number is called a time value.\nA time value may also be NaN, indicating that the Date object does not represent a specific instant of time.</p>\n<p>Time is measured in ECMAScript in milliseconds since 01 January, 1970 UTC.\nIn time values leap seconds are ignored.\nIt is assumed that there are exactly 86,400,000 milliseconds per day.\nECMAScript Number values can represent all integers form -9,007,199,254,740,992 to 9,007,254,740,993;\nthis range suffices to measure times to millisecond precision for any instant that is within approximately 285,616 years,\nforward or backward, from 01 January,1970 UTC.</p>\n<p>The actual range of times supported by ECMAScript Date objects is slightly smaller:\nexactly -100,000,000 days to 100,000,000 days measures relative to midnight at the beginning of 01 January, 1970 UTC.\nThis gives a range of 8,640,000,000,000,000 milliseconds to either side of 01 January,1970 UTC.</p>\n<p>The exact moment of midnight at the beginning of 01 January,1970 UTC is represented by the value +0.</p>\n<h3 id=\"-\">时间值和时间取值范围</h3>\n<p>一个日期对象包含一个表示精确到毫秒的时间点的数字。\n这个数字被称作为时间值。\n时间值也可以为NaN，表示这个时间对象没有代表一个特定的时间点。</p>\n<p>在ECMAScript中，时间从时间标准时间1970年一月开始以毫秒为单位被计量的。\n在时间值中闰秒被忽略。\n假设每天恰好是864000000毫秒。\nECMAScript 数字值可以由-9007199254740992到9007199254740993的所有整数来表示，\n这个范围足够计量时间到世界标准时间1970年一月一日前后大约285616年内的精确到每毫秒的时间点。</p>\n<p>ECMAScript日期对象支持的真实时间范围略小一点：\n准确的为：相对于世界时间一月一日开始的午夜的-100000000天到100000000天。\n这提供了世界标准时间1970年一月一日两侧的8640000000000000毫秒。</p>\n<p>世界标准时间1970年一月一日开始的午夜那一确切的时刻表示的值为+0。</p>\n<h3 id=\"day-number-and-time-within-day\">Day Number and Time within Day</h3>\n<p>A given time value <code>t</code> belongs to day number\n                <code>Day(t) = floor(t/msPerDay)</code>\nwhere the number of milliseconds per day is\n                <code>msPerDay = 86400000</code>\nThe remainder is called the time within the day:\n                <code>TimeWithinDay(t) = t modulo msPerDay</code></p>\n<h3 id=\"-\">天数和一天内的时间</h3>\n<p>给定时间值<code>t</code>有多少天\n            <code>Day(t) = floor(t / msPerDay)</code>\n每天多少毫秒数：\n            <code>msPerDa = 86400000</code>\n被访问的时间在一天内的剩余数：\n            <code>TimeWithinDay(t) = t modulo msPerDay</code></p>\n<h3 id=\"year-number\">Year Number</h3>\n<p>ECMAScript uses an extrapolated Gregorian system to map a day number to a year number\nand to determine the month and date within that year.\nIn this system, leap years are precisely those which are (divisible by 4)\nand ((not divisible by 100) or (divisible by 400)）.\nThe number of days in year number <code>y</code> is therefore defined by</p>\n<pre><code>        DaysInYear(y)   = 365 if (y modulo 4) != 0\n                        = 366 if (y modulo 4) = 0 and (y modulo 100) !=0\n                        = 365 if (y modulo 100) = 0 and (y modulo 400) != 0\n                        = 366 if (y module 400) = 0\n</code></pre><p>All non-leap years have 365 days with the usual number of days per month\nand leap years have an extra day in February.\nThe day number of the first day of year <code>y</code> is given by:\n<code>DayFromYear(y) = 365 x (y - 1970) + floor((y - 1969)/4) - floor((y-1901)/100) + floor((y - 1601)/400)</code>\nThe time value of the start of a year is:\n<code>TimeFromYear(y) = msPerDay x DayFromYear(y)</code>\nA time value determines a year by:\n<code>YearFromTime(t) = the largest integer y (closest to positive infinity) such that TimeFromYear(y)&lt;=t</code>\nThe leap-year function is 1 for a time within a leap year and otherwise is zero:\n<code>InLeapYear(t)   = 0 if DaysInYear(YearFromTime(t)) = 365\n                        = 1 if DaysInYear(YearFromTime(t)) = 366</code></p>\n<h3 id=\"-\">年数</h3>\n<p>ECMAScript 使用 格林系统推算天数到年数的演算，判定在这一年中某月的天数。\n在这个系统中，闰年是精确的，可以被4整除的数种，不能被100整除或者可以被400整除的数。\n在年数<code>y</code>中的天数可以被这样定义：</p>\n<pre><code>        DaysInYear(y)   = 365 if (y modulo 4) != 0\n                        = 366 if (y modulo 4) = 0 and (y modulo 100) != 0\n                        = 365 if (y modulo 100) = 0 and (y modulo 400) !=0\n                        = 366 if (y modulo 400) = 0\n</code></pre><p>所用的非闰年都有365天，它的每个月多是正常的天数，闰年在二月份会多出一天。\n年<code>y</code>的第一天的天数可以这么得出：\n<code>DayFromYear(y) = 365 x (y -1970) + floor((y-1969)/4) - floor ((y - 1901)/100) + floor((y - 1601)/400)</code>\n一年开始的的时间值为：\n<code>TimeFormYear(y) = msPerDay x DayFromYear(y)</code>\n确定一个时间值在哪一年中：\n<code>YearFromTime(t) = the largest integer y (closest to positive infinity) such that TimeFromYear(y)&lt;=t</code>\n一个时间点在闰年中函数值为1否则为0：\n<code>InLeapYear(t)   = 0 if DayInYear(YearFromTime(t)) = 365\n                        = 1 if DayInYear(YearFromTime(t)) = 366</code></p>\n<h3 id=\"month-number\">Month Number</h3>\n<p>Months are identified by integer in the range 0 to 11, inclusive.\nThe mapping MonthFromTime(t) from a time value <code>t</code> to a month number is defined by:</p>\n<pre><code>        MonthFromTime(t) = 0 if 0                       &lt;= DayWithinYear(t) &lt; 31\n                         = 1 if 31                      &lt;= DayWithinYear(t) &lt; 59 + InLeapYear(t)\n                         = 2 if 59 + InLeapYear(t)      &lt;= DayWithinYear(t) &lt; 90 + InLeapYear(t)\n                         = 3 if 90 + InLeapYear(t)      &lt;= DayWithinYear(t) &lt; 120 + InLeapYear(t)\n                         = 4 if 120 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 151 + InLeapYear(t)\n                         = 5 if 151 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 181 + InLeapYear(t)\n                         = 6 if 181 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 212 + InLeapYear(t)\n                         = 7 if 212 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 243 + InLeapYear(t)\n                         = 8 if 243 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 273 + InLeapYear(t)\n                         = 9 if 273 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 304 + InLeapYear(t)\n                         = 10 if 304 + InLeapYear(t)    &lt;= DayWithinYear(t) &lt; 334 + InLeapYear(t)\n                         = 11 if 334 + InLeapYear(t)    &lt;= DayWithinYear(t) &lt; 365 + InLeapYear(t)\n</code></pre><p>where\n<code>DayWithinYear(t) = Day(t) - DayFromYear(YearFromTime(t))</code>\nA month value of 0 specifies January; 1 specifies February; 2 specifies March;\n3 specifies April; 4 specifies May; 5 specifies June; 6 specifies July;\n7 specifies August; 8 specifies September; 9 specifies October;\n10 specifies November; and 11 specifies December.\nNote that MonthFromTime(0) = 0,corresponding to Thursday,01 January, 1970.</p>\n<h3 id=\"-\">月数</h3>\n<p>月是由0到11包括的的整数标识。\n一个时间值<code>t</code>的映射到一个月数的MonthFromTime(t)的定义为：</p>\n<pre><code>        MonthFromTime(t) = 0 if 0                       &lt;= DayWithinYear(t) &lt; 31\n                         = 1 if 31                      &lt;= DayWithinYear(t) &lt; 59 + InLeapYear(t)\n                         = 2 if 59 + InLeapYear(t)      &lt;= DayWithinYear(t) &lt; 90 + InLeapYear(t)\n                         = 3 if 90 + InLeapYear(t)      &lt;= DayWithinYear(t) &lt; 120 + InLeapYear(t)\n                         = 4 if 120 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 151 + InLeapYear(t)\n                         = 5 if 151 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 181 + InLeapYear(t)\n                         = 6 if 181 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 212 + InLeapYear(t)\n                         = 7 if 212 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 243 + InLeapYear(t)\n                         = 8 if 243 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 273 + InLeapYear(t)\n                         = 9 if 273 + InLeapYear(t)     &lt;= DayWithinYear(t) &lt; 304 + InLeapYear(t)\n                         = 10 if 304 + InLeapYear(t)    &lt;= DayWithinYear(t) &lt; 334 + InLeapYear(t)\n                         = 11 if 334 + InLeapYear(t)    &lt;= DayWithinYear(t) &lt; 365 + InLeapYear(t)\n</code></pre><p>月值0代表一月，1代表二月，2代表三月，3代表四月，4代表五月，5代表六月，6代表七月，7代表八月，8代表九月，9代表10月，10代表十一月，11代表十二月。\n注意：<code>MonthFromTime(0) = 0</code>,对应1970年一月一日星期四。</p>\n<h3 id=\"date-number\">Date Number</h3>\n<p>A date number is identified by an integer in the range 1 through 31, inclusive.\nThe mapping DateFromTime(t) from a time value <code>t</code> to a month number is defined by:</p>\n<pre><code>        DateFromTime(t) = DayWithinYear(t) + 1                      if MonthFromTime(t) = 0\n                        = DayWithinYear(t) - 30                     if MonthFromTime(t) = 1\n                        = DayWithinYear(t) - 58 - InLeapYear(t)     if MonthFromTime(t) = 2\n                        = DayWithinYear(t) - 89 - InLeapYear(t)     if MonthFromTime(t) = 3\n                        = DayWithinYear(t) - 119 - InLeapYear(t)    if MonthFromTime(t) = 4\n                        = DayWithinYear(t) - 150 - InLeapYear(t)    if MonthFromTime(t) = 5\n                        = DayWithinYear(t) - 180 - InLeapYear(t)    if MonthFromTime(t) = 6\n                        = DayWithinYear(t) - 211 - InLeapYear(t)    if MonthFromTime(t) = 7\n                        = DayWithinYear(t) - 242 - InLeapYear(t)    if MonthFromTime(t) = 8\n                        = DayWithinYear(t) - 272 - InLeapYear(t)    if MonthFromTime(t) = 9\n                        = DayWithinYear(t) - 303 - InLeapYear(t)    if MonthFromTime(t) = 10\n                        = DayWithinYear(t) - 333 - InLeapYear(t)    if MonthFromTime(t) = 11\n</code></pre><h3 id=\"-\">日期数字</h3>\n<p>一个日期数字由1到31范围内的数字表示。\n时间值<code>t</code>映射到月数的方法<code>DateFromTime(t)</code>的定义为：</p>\n<pre><code>        DateFromTime(t) = DayWithinYear(t) + 1                      if MonthFromTime(t) = 0\n                        = DayWithinYear(t) - 30                     if MonthFromTime(t) = 1\n                        = DayWithinYear(t) - 58 - InLeapYear(t)     if MonthFromTime(t) = 2\n                        = DayWithinYear(t) - 89 - InLeapYear(t)     if MonthFromTime(t) = 3\n                        = DayWithinYear(t) - 119 - InLeapYear(t)    if MonthFromTime(t) = 4\n                        = DayWithinYear(t) - 150 - InLeapYear(t)    if MonthFromTime(t) = 5\n                        = DayWithinYear(t) - 180 - InLeapYear(t)    if MonthFromTime(t) = 6\n                        = DayWithinYear(t) - 211 - InLeapYear(t)    if MonthFromTime(t) = 7\n                        = DayWithinYear(t) - 242 - InLeapYear(t)    if MonthFromTime(t) = 8\n                        = DayWithinYear(t) - 272 - InLeapYear(t)    if MonthFromTime(t) = 9\n                        = DayWithinYear(t) - 303 - InLeapYear(t)    if MonthFromTime(t) = 10\n                        = DayWithinYear(t) - 333 - InLeapYear(t)    if MonthFromTime(t) = 11\n</code></pre><h3 id=\"week-day\">Week Day</h3>\n<p>The weekday for a particular time value <code>t</code> is defined as\n<code>WeekDay(t)  = (Day(t) + 4) modulo 7</code>\nA weekday value if 0 specifies Sunday; 1 specifies Monday; 2 specifies Tuesday;\n3 specifies Wednesday; 4 specifies Thursday; 5 specifies Friday; and 6 specifies Saturday.\nNote that WeekDay(0) = 4, corresponding to Thursday, 01 January, 1970.</p>\n<h3 id=\"-\">周 日</h3>\n<p>给定时间值<code>t</code>的周几的规定为：\n<code>WeekDay(t) = (Day(t) + 4) modulo 7</code>\n一个周汁可以为，0代表周日，1代表周一，2代表周二，3代表周三，4代表周四，5代周五，6代表周六。\n注意：<code>WeekDay(0) = 4</code>，1970年一月一日对应周四。</p>\n<h3 id=\"local-time-zone-adjustment\">Local Time Zone Adjustment</h3>\n<p>An implementation of ECMAScript is expected to determine the local time zone adjustment.\nThe local time zone adjustment is a value localTZA measured in milliseconds which when added to UTC represents the local standard time.\nDaylight saving time is not reflected by LocalTZA.\nThe value LocalTZA does not vary with time but depends only the geographic location.</p>\n<h3 id=\"-\">本地时区调整</h3>\n<p>一个ECMAScript的实现希望确定本地时区调整。\n当添加UTC代表本地标准时间时，本地时区调整是一个以毫秒衡量的值<code>localTZA</code>。\n值<code>localTZA</code>不随时间彪悍，但取决于地理位置。</p>\n<h3 id=\"daylight-saving-time-adjustment\">Daylight Saving Time Adjustment</h3>\n<p>An implementation of ECMAScript is expected to determine the daylight saving time algorithm.\nThe algorithm to determine the daylight saving time adjustment DaylightSavingTA(t),\nmeasured in milliseconds,must depend only on four thing.\n(1) the time since the beginning if the year\n<code>t - TimeFromYear(YearFromTime(t))</code>\n(2) whether <code>t</code> is in a leap year\n<code>InLeapYear(t)</code>\n(3) the week day of the beginning of the year\n<code>WeekDay(TimeFromYear(YearFromTime(t)))</code>\nand (4) the geographic location.</p>\n<p>The implementation of ECMAScript should not try to determine whether the exact time was subject to daylight saving time.\nbut just whether daylight saving time would have been in effect if the current daylight saving time algorithm had been used at the time.\nThis avoids complications such as taking into account the years that the locale observed daylight saving time year round.</p>\n<p>If the host environment provides functionality for determining daylight saving time.\nthe implementation of ECMAScript is free to map the year in question to an equivalent year\n(same leap-year-ness and same starting week day for the year)\nfor which the host environment provides daylight saving time information.\nThe only restriction is that all equivalent years should produce the same result.</p>\n<h2 id=\"-\">#</h2>\n"},"angular/angular-service/angular-service-$$asyncCallback":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$$asyncCallback","contents":"<h1 id=\"-asynccallback\">$$asyncCallback</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$$rAF</li>\n<li>$timeout</li>\n</ul>\n"},"angular/angular-service/angular-service-$$rAF":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$$rAF","contents":"<h1 id=\"-raf\">$$rAF</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$window</li>\n<li>$timeout</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{f\n    @fn: %f,\n    = {f\n\n    }\n}\n</code></pre><h3 id=\"-\">问题</h3>\n<p>requestAnimationFrame是什么函数及其怎么用？</p>\n"},"angular/angular-service/angular-service-$$sanitizeUri":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$$sanitizeUri","contents":"<h1 id=\"-sanitizeuri\">$$sanitizeUri</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n"},"angular/angular-service/angular-service-$SceDelegate":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$SceDelegate","contents":"<h1 id=\"-scedelegate\">$SceDelegate</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$injector</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<pre><code>this.$get = = [&#39;$injector&#39;, function ($injector) {\n    return { \n        trustAs: trustAs,\n        getTrusted: getTrusted,\n        valueOf: valueOf\n    }\n}\n</code></pre><h3 id=\"-\">问题</h3>\n<p>$secDelegate的作用</p>\n"},"angular/angular-service/angular-service-$anchorScroll":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$anchorScroll","contents":"<h1 id=\"-anchorscroll\">$anchorScroll</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$window</li>\n<li>$location</li>\n<li>$rootScope</li>\n</ul>\n"},"angular/angular-service/angular-service-$animate":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$animate","contents":"<h1 id=\"-animate\">$animate</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$timeout</li>\n<li>$$asyncCallback</li>\n</ul>\n"},"angular/angular-service/angular-service-$browser":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$browser","contents":"<h1 id=\"-browser\">$browser</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$window</li>\n<li>$log</li>\n<li>$sniffer</li>\n<li>$document</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<pre><code>this.$get = [&#39;$window&#39;, &#39;$log&#39;, &#39;$sniffer&#39;, &#39;$document&#39;,\n    function ($window, $log, $sniffer, $document) {\n        return new Browser($window, $document, $log, $sniffer);\n    }\n];\n</code></pre><h3 id=\"service-\">service结构</h3>\n<pre><code>{\n    isMock: {{Boolean}},\n    $$completeOutstandingRequest: {{Function}},\n    $$incOutstandingRequestCount: {{Function}},\n    notifyWhenNoOutstandingRequests: {{Function}},\n    addPollFn: {{Function}},\n    url: {{Function}},\n    onUrlChange: {{Function}},\n    baseHref: {{Function}},\n    cookies: {{Function}},\n    defer: {{Function}},\n}\n</code></pre><h3 id=\"-\">问题</h3>\n<p>isMock代表的什么？（参考ngMock模块）</p>\n"},"angular/angular-service/angular-service-$cacheFactory":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$cacheFactory","contents":"<h1 id=\"-cachefactory\">$cacheFactory</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>(无依赖)</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{{function}\n    info: {{function}},\n    get: {{function}}\n}\n\n\n\n{f\n    @name: %f,\n    @type: %f,\n    ^state: %b,\n    ^data: %n,\n    ^capacity: %n,\n    ^lruHash: %a,\n    ^freshEnd: %a,\n    ^stale: %a,\n    - {\n\n    },\n    = {\n        put: %f,\n        get: %f,\n        remove: %f,\n        removeAll: %f,\n        destroy: %f,\n        info: %f\n    },\n    info: %f,\n    get: %f\n}\n</code></pre>"},"angular/angular-service/angular-service-$compile":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:56:16.000Z","url":"angular/angular-service/angular-service-$compile","contents":"<h1 id=\"-compile\">$compile</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$injector</li>\n<li>$interpolate</li>\n<li>$exceptionHandler</li>\n<li>$http</li>\n<li>$templateCache</li>\n<li>$controller</li>\n<li>$rootScope</li>\n<li>$document</li>\n<li>$sce</li>\n<li>$animate</li>\n<li>$$sanitizeUri</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>this.$get:-&gt;\n    @: $injector,$interpolate,$exceptionHandler,$http,$templateCache,$parse,$controller,$rootScope,$document,$sce,$animate,$$sanitizeUri\n    ^:\n        :compile-&gt;\n            @: $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext\n        :safeAddClass-&gt;\n            @: $element, className\n        :compileNodes-&gt;\n            @: nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext \n        :createBoundTranscludeFn-&gt;\n            @: scope, transcludeFn\n        :collectDirectives-&gt;\n            @: node, directives, attrs, maxPriority, ignoreDirective\n        :groupScan-&gt;\n            @: node, attrStart, attrEnd\n        :groupElementLinkFnWrapper-&gt;\n            @: dst, src\n        :compileTemplateUrl-&gt;\n            @: directives, $compileNode, tAttrs, $rootElement, preLinkFns, postLinkFns, previousCompileContext\n        :byPriority-&gt;\n            @: a, b\n        :assertNoDuplicate-&gt;\n            @: what, previousDirective, directive, element\n        :addTextInterpolateDirective\n            @: directive, text\n        :getTrustedContext-&gt;\n            @: node, attrNormalizedName\n        :addAttrInterpolateDirective-&gt;\n            @: node, directives, value, name\n        :replaceWith-&gt;\n            @: $rootElement, elementsToRemove, newNode\n        :cloneAndAnnotateFn-&gt;\n            @: fn, annotation\n    -:\n\n    &gt;: ^compile\n</code></pre><h3 id=\"-\">注意点</h3>\n<ol>\n<li>理解方面，为提供方法而存在的方法，指令怎么在DOM中表现出行为，需要作用于node、scope、controller、\n其需要一个方法来完成，这个方法就是$compile service的返回值，所有$compile这个service为为了提供方法而存在的方法\n是指令在DOM中表现出来的方法为$compile的返回值publicLinkFn，\npublicLinkFn 在执行时调用$compile阶段产生的compositeLinkFn函数，</li>\n<li>compile函数的返回值为 函数名为publicLinkFn的函数，此函数在bootstrap中被调用，其调用方式为 <code>compile（scope）</code>\n这里只用有一个实参，但是compile作为$compile service暴露出来的函数，可以被手动点用，在调用时，\n第二个参数为cloneConnectFn，此函数使用时，$compileNodes被clone，被被cloneConnectFn函数所调用，\n第三个参数为transcludeControllers，次参数为一个数组，它使用时，分别为$compileNodes赋予一个Controller</li>\n<li>关于compositeLinkFn的调用，此时其中含有多层递归，其具体递归的深度和node的结构有关\n每次层中，可能有好几个node，要看这个node有没有兄弟节点，\n对于一个node来说，最多可能有两个函数，分别是nodeLinkFn和childLinkFn，nodeLinkFn为执行当前node的函数，childLinkFn为执行下一代node的函数\nnodeLinkFn为applyDirectivesToNode的返回值，childLinkFn函数为递归调用的compileNodes的返回值。\n当nodeLinkFn存在时，执行nodeLinkFn，其中该函数的第一个参数为childLinkFn，这样吧子代node的执行放在nodeLinkFn内部</li>\n<li>compositeLinkFn的调用，有四个参数，其中publicLinkFn函数中的的调用方式是\n<code>compositeLinkFn(scope,$linkNode,$linkNode)</code></li>\n</ol>\n"},"angular/angular-service/angular-service-$controller":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$controller","contents":"<h1 id=\"-controller\">$controller</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$injector</li>\n<li>$window</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数代码</h3>\n<pre><code>this.$get = [&#39;$injector&#39;, &#39;$window&#39;, function ($injector, $window) {\n    return {{Function}}\n}];\n</code></pre><h2 id=\"-\">#</h2>\n"},"angular/angular-service/angular-service-$document":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$document","contents":"<h1 id=\"-document\">$document</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li><code>$window</code></li>\n</ul>\n<h3 id=\"get-\">get函数代码</h3>\n<pre><code>this.$get = [&#39;$window&#39;, function (window) {\n        return jqLite(window.document);\n    }];\n</code></pre><h3 id=\"service-\">service结构</h3>\n<pre><code>{\n    __proto__: { // 此处表示原型链上的属性和方法\n\n    }\n}\n</code></pre>"},"angular/angular-service/angular-service-$exceptionHandler":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$exceptionHandler","contents":"<h1 id=\"-exceptionhandler\">$exceptionHandler</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$log</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<pre><code>this.$get = [&#39;$log&#39;, function ($log) {\n    return function (exception, cause) {\n        $log.error.apply($log, arguments);\n    };\n}];\n</code></pre><h3 id=\"-\">问题</h3>\n<p>参数个数，同$log中的问题</p>\n"},"angular/angular-service/angular-service-$filter":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$filter","contents":"<h1 id=\"-filter\">$filter</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$injector</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<pre><code> this.$get = [&#39;$injector&#39;, function ($injector) {\n    return function (name) {\n        return $injector.get(name + &#39;Filter&#39;);\n    };\n }];\n</code></pre><h3 id=\"-\">问题</h3>\n"},"angular/angular-service/angular-service-$http":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$http","contents":"<h1 id=\"-http\">$http</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$httpBackend</li>\n<li>$browser</li>\n<li>$cacheFactory</li>\n<li>$rootScope</li>\n<li>$q</li>\n<li>$injector</li>\n</ul>\n"},"angular/angular-service/angular-service-$httpBackend":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$httpBackend","contents":"<h1 id=\"-httpbackend\">$httpBackend</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$browser</li>\n<li>$window</li>\n<li><p>$document</p>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<p>  this.$get = [&#39;$browser&#39;, &#39;$window&#39;, &#39;$document&#39;, function ($browser, $window, $document) {</p>\n<pre><code>  return createHttpBackend($browser, createXhr, $browser.defer, $window.angular.callbacks, $document[0]);\n</code></pre><p>  }];</p>\n</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{{Function}}\n</code></pre><h3 id=\"-\">问题</h3>\n<pre><code>callbacks[callbackId] = function (data) {\n    callbacks[callbackId].data = data;\n    callbacks[callbackId].called = true;\n};\n</code></pre><p>此函数未执行，那么callbacks[callbackId].called 的值为false， 这样event.type === &#39;error&#39;</p>\n"},"angular/angular-service/angular-service-$interpolate":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$interpolate","contents":"<h1 id=\"-interpolate\">$interpolate</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$parse</li>\n<li>$exceptionHandler</li>\n<li>$sce</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{\n\n}\n</code></pre>"},"angular/angular-service/angular-service-$interval":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$interval","contents":"<h1 id=\"-interval\">$interval</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$rootScope</li>\n<li>$window</li>\n<li>$q</li>\n</ul>\n"},"angular/angular-service/angular-service-$location":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$location","contents":"<h1 id=\"-location\">$location</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$rootScope</li>\n<li>$browser</li>\n<li>$sniffer</li>\n<li>$rootElement</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{\n    $$html5: {{boolean}},\n    $$url: {{string}},\n    $$absUrl: {{string}},\n    $$search: {{string}},\n    $$hash: {{string}},\n    $$path: {{string}},\n    $$parse: {{Function}},\n    $$compose: {{Function}},\n    $$rewrite: {{Function}},\n    __proto__: {\n        $$html5: {{boolean}},\n        $$replace: {{boolean}},\n        absUrl: {{Function}},\n        url: {{Function}},\n        protocol: {{Function}},\n        host: {{Function}},\n        port: {{Function}},\n        path: {{Function}},\n        search: {{Function}},\n        hash: {{Function}},\n        replace: {{Function}}\n}\n</code></pre>"},"angular/angular-service/angular-service-$log":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$log","contents":"<h1 id=\"-log\">$log</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$window</li>\n</ul>\n<h3 id=\"get-\">get函数代码</h3>\n<pre><code>this.$get = [&#39;$window&#39;, function ($window) {\n        return {\n            log: {{function}},\n\n            info: {{function}},\n\n            warn: {{function}},\n\n            error: {{function}},\n\n            debug: {{function}}\n        };\n    }];\n</code></pre>"},"angular/angular-service/angular-service-$parse":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-08-09T03:22:03.000Z","url":"angular/angular-service/angular-service-$parse","contents":"<h1 id=\"-parse\">$parse</h1>\n<h5 id=\"-\">根作用域服务</h5>\n<h2 id=\"-\">服务依赖</h2>\n<ul>\n<li>$filter</li>\n<li>$sniffer</li>\n<li>$log</li>\n</ul>\n<h2 id=\"this-get-\">this.$get函数</h2>\n<pre><code>this.$get = [&#39;$filter&#39;, &#39;$sniffer&#39;, &#39;$log&#39;, function ($filter, $sniffer, $log) {\n    return {{Function}}  \n}\n</code></pre><h2 id=\"-\">代码</h2>\n<p>分两个部分Lexer(词法解析器)和Parser(语法解析器)</p>\n<h3 id=\"lexer-\">Lexer属性</h3>\n<ol>\n<li>options  选项</li>\n<li>ch       当前的字符</li>\n<li>lastCh   下一个字符</li>\n<li>text     当前字符串</li>\n<li>index    当前序列数</li>\n<li>tokens   标识（暂时叫标识，也找不到更好的翻译，最小的语法单元）序列</li>\n</ol>\n<h3 id=\"lexer-\">Lexer方法</h3>\n<ol>\n<li>lex          解析text字符串为标识序列</li>\n<li>is           参数为chars，判断ch是不是该字符</li>\n<li>was          参数为chars，判断lastCh是不是该字符</li>\n<li>peek         参数为i，默认值为1，获取index向后的第i个字符</li>\n<li>isNumber     判断是否为数字</li>\n<li>isWhitespace 判断是否为空格</li>\n<li>isIdent      判断是否为标识符</li>\n<li>isExpOperator判断是否为表达式符号</li>\n<li>throwError   抛出异常</li>\n<li>readNumber  读取数字</li>\n<li>readIdent   读取标识符</li>\n<li>readString  读取字符串</li>\n</ol>\n<h4 id=\"this-lex-\">this.lex方法详解</h4>\n<p>此方法用来把text属性解析成javascript语法的表达式序列\n并把每一个序列<code>token</code>放入到tokens属性中，\n在此方法中，从text的第一位字符开始向后遍历，在循环中解析不同的类型\nlexer并不支持所有的javascript合法字符，它现在支持的有六种  </p>\n<ol>\n<li>字符串</li>\n<li>数字</li>\n<li>标识符</li>\n<li>(){}[].,;:?这几种符号</li>\n<li>空格</li>\n<li>操作符（null、true、false、undefined、+、-、/、%、^、=、===、!==、==、!=、&lt;、&gt;、&amp;&amp;、||、&amp;、|、!）\n直到text被便利结束，返回tokens属性。<h5 id=\"this-readnumber-\">this.readNumber方法详解</h5>\n此方法用于读取数字\n无参数\n//todo 不同的number的不同分类<h6 id=\"-token-\">返回的<code>token</code>的结构</h6>\n {<pre><code> index: start\n text: number\n literal: true\n constant: true\n fn: function(){\n     return number\n }\n</code></pre> }</li>\n</ol>\n<h5 id=\"this-readstring-\">this.readString方法详解</h5>\n<p>此方法用于读取字符串，\n参数为quote，其中可能为 <code>&#39;</code>或者<code>&quot;</code>，字符串的开始标识\n从<code>&#39;</code>或者<code>&quot;</code>开始遍历text在遍历中有四种情况处理  </p>\n<ol>\n<li>escape string，如果是则又分两种情况:\n以u开始的escape string 和特殊的escape string(<code>\\n</code>、 <code>\\f</code>、 <code>\\r</code>、 <code>\\t</code>、 <code>\\v</code>、 <code>&#39;</code>、 <code>&quot;</code>)</li>\n<li><code>\\</code>字符 说明下面是escape string</li>\n<li>quote，字符串的结束，把获取到的字符串push到tokens序列中</li>\n<li>其他字符，均可为字符串<h6 id=\"-token-\">返回的<code>token</code>的结构</h6>\n {<pre><code> index: start\n text:  rawString\n string: string\n literal: true\n constant: true\n fn: function(){\n     return string\n }\n</code></pre> }<h5 id=\"this-readident-\">this.readIdent方法详解</h5>\n</li>\n</ol>\n"},"angular/angular-service/angular-service-$q":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$q","contents":"<h1 id=\"-q\">$q</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$rootScope</li>\n<li>$exceptionHandler<h3 id=\"this-get-\">this.$get函数</h3>\n</li>\n</ul>\n<pre><code>this.$get = [&#39;$rootScope&#39;, &#39;$exceptionHandler&#39;, function ($rootScope, $exceptionHandler) {\n    return qFactory(function (callback) {\n        $rootScope.$evalAsync(callback);\n    }, $exceptionHandler);\n}];\n</code></pre><h3 id=\"-\">结构</h3>\n<pre><code>{\n    defer: {{\n       function(){\n            return {\n                resolve: {{Function}},\n                reject: {{Function}},\n                notify: {{Function}},\n                promise: \n                     {\n                        then: {{Function}},\n                        catch: {{Function}},\n                        finally: {{Function}}\n                    },\n            }\n\n        }\n    }},\n    reject: {{Function}},\n    when: {{Function}},\n    all: {{Function}}\n\n}\n</code></pre>"},"angular/angular-service/angular-service-$rootScope":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-08-04T14:56:41.000Z","url":"angular/angular-service/angular-service-$rootScope","contents":"<h1 id=\"-rootscope\">$rootScope</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$injector</li>\n<li>$exceptionHandler</li>\n<li>$parse</li>\n<li>$browser<h3 id=\"this-get-\">this.$get函数</h3>\n</li>\n</ul>\n<pre><code>this.$get = [&#39;$injector&#39;, &#39;$exceptionHandler&#39;, &#39;$parse&#39;, &#39;$browser&#39;,\n    function ($injector, $exceptionHandler, $parse, $browser) {\n        return new function Scope() {\n                                   this.$id = nextUid();\n                                   this.$$phase = this.$parent = this.$$watchers =\n                                       this.$$nextSibling = this.$$prevSibling =\n                                           this.$$childHead = this.$$childTail = null;\n                                   this[&#39;this&#39;] = this.$root = this;\n                                   this.$$destroyed = false;\n                                   this.$$asyncQueue = [];\n                                   this.$$postDigestQueue = [];\n                                   this.$$listeners = {};\n                                   this.$$listenerCount = {};\n                                   this.$$isolateBindings = {};\n                               }\n}]\n</code></pre><h3 id=\"-\">结构</h3>\n<pre><code>{\n    $id: {{number}},\n    $$phase: {{null|}},\n    $parent: {{null|Scope}},\n    $$watchers: \n        [\n            {\n                fn: {{Function}},\n                last: {{Function}},\n                get: {{Function}},\n                exp: {{Exp}},\n                eq: {{boolean}}\n            }\n        ],\n    $$nextSibling: {{null|Scope}},\n    $$prevSibling: {{null|Scope}},\n    $$childHead: {{null|Scope}},\n    $$childTail: {{null|Scope}},\n    $root: {{null|Scope}},\n    &#39;this&#39;: {{Scope}},\n    $$destroyed: {{boolean}},\n    $$asyncQueue: {{Array}},\n    $$postDigestQueue: {{Array}},\n    $$listeners: {{Object}},\n    $$listenerCount: {{Object}},\n    $$isolateBindings: {{Object}},\n    __proto__:{\n        constructor: Scope,\n        $new: {{Function}},\n        $watch: {{Function}},\n        $watchGroup: {{Function}},\n        $watchCollection: {{Function}},\n        $digest: {{Function}},\n        $destroy: {{Function}},\n        $eval: {{Function}},\n        $evalAsync: {{Function}},\n        $$postDigest: {{Function}},\n        $apply: {{Function}},\n        $on: {{Function}},\n        $emit: {{Function}},\n        $broadcast: {{Function}}\n    }\n}\n</code></pre><h3 id=\"scope-\">Scope对象的属性</h3>\n<ol>\n<li>$id \n 由统一的id生成器 nextUid自动生成，用于标识每个不同的Scope实例</li>\n<li>$$phase\n 标识该scope正在进行的操作</li>\n<li>$root\n 根Scope实例</li>\n<li>this\n Scope实例本身。</li>\n<li>$parent<br> 用来描述Scope实例间的关系，指向父Scope实例，即：产生此Scope实例的Scope实例，一般使用$new方法来产生</li>\n<li>$$nextSibling\n 用来描述Scope实例间兄弟的关系，指向Scope实例的上一个兄弟Scope实例。</li>\n<li>$$prevSibling\n 用来描述Scope实例间兄弟的关系，指向Scope实例的下一个兄弟Scope实例。</li>\n<li>$$childHead\n 用来描述Scope实例间子Scope实例的关系，指向Scope实例的下一个子Scope实例中的第一个，主要用来维护子Scope实例的兄弟关系。</li>\n<li>$$childTail\n 用来描述Scope实例间子Scope实例的关系，指向Scope实例的下一个子Scope实例中的最后一个，主要用来维护子Scope实例的兄弟关系。</li>\n<li>$$$watchers\n观察者属性</li>\n</ol>\n<ol>\n<li>$$destroyed</li>\n<li>$$asyncQueue</li>\n<li>$$postDigestQueue</li>\n<li>$$listeners\n监听者属性</li>\n<li>$$listenerCount</li>\n<li>$$isolateBindings<h3 id=\"scope-\">Scope对象的方法</h3>\n</li>\n<li>$new\n 用于创建新的Scope实例，其中可以传递一个可选的参数<code>isolate</code>,\n 创建过程可以分为两步；<br> 第一步：创建新的Scope实例，其中<ol>\n<li>当<code>isolate</code>为存在时，生成一个没有继承关系的全新的Scope实例，</li>\n<li>当<code>isolate</code>不存在时，先产生一个创建子作用域实例的构造方法<code>$$childScopeClass</code>，用于创建新的继承自当前Scope实例的Scope实例，新的Scope实例的<code>$$childScopeClass</code>方法会被覆盖为<code>null</code><br>第二步：维护Scope实例的关系\n不管<code>isolate</code>为<code>true</code>或<code>false</code>新创建的Scope实例都会被追加到子Scope的尾部，即$$childTail上，并维护好子Scope实例的兄弟关系。</li>\n</ol>\n</li>\n<li><p>$watch</p>\n</li>\n<li><p>$watchCollection</p>\n</li>\n<li>$digest</li>\n<li>$destroy</li>\n<li>$eval</li>\n<li>$evalAsync</li>\n<li>$$postDigest</li>\n<li>$apply</li>\n<li>$on</li>\n<li>$emit</li>\n<li>$broadcast</li>\n</ol>\n<h3 id=\"-\">问题</h3>\n<p>$watch监听的函数式怎么做的轮询\n$$asyncQueue用来缓冲的，那么为什么是$q依赖于$rooScope，而不是$rootScope依赖$q,这样就不需要asyncQueue了。</p>\n"},"angular/angular-service/angular-service-$sce":{"releaseTime":"2014-07-17T06:32:29.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$sce","contents":"<h1 id=\"-sce\">$sce</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$parse</li>\n<li>$sniffer</li>\n<li>$sceDelegate</li>\n</ul>\n<h3 id=\"-\">结构</h3>\n<pre><code>{\n    HTML: &#39;html&#39;,\n    CSS: &#39;css&#39;,\n    URL: &#39;url&#39;,\n    RESOURCE_URL: &#39;resourceUrl&#39;,\n    JS: &#39;js&#39;,\n    isEnabled: {{Function}},\n    trustAs: {{Function}},\n    getTrusted: {{Function}},\n    valueOf: {{function}},\n    parseAs: {{Function}},\n    parse_as_html: {{Function}},\n    get_trusted_html: {{Function}},\n    trust_as_html: {{Function}},\n    parse_as_css: {{Function}},\n    get_trusted_css: {{Function}},\n    trust_as_css: {{Function}},\n    parse_as_url: {{Function}},\n    get_trusted_url: {{Function}},\n    trust_as_url: {{Function}},\n    parse_as_resourceUrl: {{Function}},\n    get_trusted_resourceUrl: {{Function}},\n    trust_as_resourceUrl: {{Function}},\n    parse_as_js: {{Function}},\n    get_trusted_js: {{Function}},\n    trust_as_js: {{Function}},\n}\n</code></pre>"},"angular/angular-service/angular-service-$sniffer":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$sniffer","contents":"<h1 id=\"-sniffer\">$sniffer</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$window</li>\n<li>$document</li>\n</ul>\n<h3 id=\"this-get-\">this.$get函数</h3>\n<pre><code>this.$get = [&#39;$window&#39;, &#39;$document&#39;, function ($window, $document) {\n    return {\n        history: !!($window.history &amp;&amp; $window.history.pushState &amp;&amp; !(android &lt; 4) &amp;&amp; !boxee),\n        hashchange: &#39;onhashchange&#39; in $window &amp;&amp; (!documentMode || documentMode &gt; 7),\n        hasEvent: function (event) {\n            if (event == &#39;input&#39; &amp;&amp; msie == 9) return false;\n            if (isUndefined(eventSupport[event])) {\n                var divElm = document.createElement(&#39;div&#39;);\n                eventSupport[event] = &#39;on&#39; + event in divElm;\n            }\n            return eventSupport[event];\n        },\n        csp: csp(),\n        vendorPrefix: vendorPrefix,\n        transitions: transitions,\n        animations: animations,\n        android: android,\n        msie: msie,\n        msieDocumentMode: documentMode\n    };\n}];\n</code></pre><h3 id=\"-\">问题</h3>\n<p>csp是什么？\nhashChange的兼容性</p>\n"},"angular/angular-service/angular-service-$templateCache":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$templateCache","contents":"<h1 id=\"-templatecache\">$templateCache</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$cacheFactory</li>\n</ul>\n"},"angular/angular-service/angular-service-$timeout":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:53:24.000Z","url":"angular/angular-service/angular-service-$timeout","contents":"<h1 id=\"-timeout\">$timeout</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>$rootScope</li>\n<li>$browser</li>\n<li>$q</li>\n<li>$exceptionHandler</li>\n</ul>\n"},"angular/angular-service/angular-service-$window":{"releaseTime":"2014-07-17T06:32:30.000Z","refreshTime":"2014-07-17T04:56:16.000Z","url":"angular/angular-service/angular-service-$window","contents":"<h1 id=\"-window\">$window</h1>\n<h2 id=\"-\">根作用域服务</h2>\n<h3 id=\"-\">服务依赖</h3>\n<ul>\n<li>（无依赖）</li>\n</ul>\n<h3 id=\"get-\">get函数代码</h3>\n<pre><code>this.$get = valueFn(window);\n</code></pre><h3 id=\"ooscript\">OOScript</h3>\n<pre><code>this.$get-&gt;\n    &gt;: valueFn(window)\n\n    ^: value:-&gt;\n        @: value\n        &gt;: -&gt;@value\n</code></pre>"}}