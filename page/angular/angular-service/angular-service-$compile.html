<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8'/>
    <meta name="description" content="Blog : Qingo" />
    <title>Qingo的博客</title>
</head>
<body>
<h1>$compile</h1>

<h2>根作用域服务</h2>

<h3>服务依赖</h3>

<ul><li>$injector</li><li>$interpolate</li><li>$exceptionHandler</li><li>$http</li><li>$templateCache</li><li>$controller</li><li>$rootScope</li><li>$document</li><li>$sce</li><li>$animate</li><li>$$sanitizeUri</li></ul>

<h3>结构</h3>

<pre><code>this.$get:-&gt;
    @: $injector,$interpolate,$exceptionHandler,$http,$templateCache,$parse,$controller,$rootScope,$document,$sce,$animate,$$sanitizeUri
    ^:
        :compile-&gt;
            @: $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext
        :safeAddClass-&gt;
            @: $element, className
        :compileNodes-&gt;
            @: nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext 
        :createBoundTranscludeFn-&gt;
            @: scope, transcludeFn
        :collectDirectives-&gt;
            @: node, directives, attrs, maxPriority, ignoreDirective
        :groupScan-&gt;
            @: node, attrStart, attrEnd
        :groupElementLinkFnWrapper-&gt;
            @: dst, src
        :compileTemplateUrl-&gt;
            @: directives, $compileNode, tAttrs, $rootElement, preLinkFns, postLinkFns, previousCompileContext
        :byPriority-&gt;
            @: a, b
        :assertNoDuplicate-&gt;
            @: what, previousDirective, directive, element
        :addTextInterpolateDirective
            @: directive, text
        :getTrustedContext-&gt;
            @: node, attrNormalizedName
        :addAttrInterpolateDirective-&gt;
            @: node, directives, value, name
        :replaceWith-&gt;
            @: $rootElement, elementsToRemove, newNode
        :cloneAndAnnotateFn-&gt;
            @: fn, annotation
    -:

    &gt;: ^compile</code></pre>

<h3>注意点</h3>

<ol><li>理解方面，为提供方法而存在的方法，指令怎么在DOM中表现出行为，需要作用于node、scope、controller、
其需要一个方法来完成，这个方法就是$compile service的返回值，所有$compile这个service为为了提供方法而存在的方法
是指令在DOM中表现出来的方法为$compile的返回值publicLinkFn，
publicLinkFn 在执行时调用$compile阶段产生的compositeLinkFn函数，</li><li>compile函数的返回值为 函数名为publicLinkFn的函数，此函数在bootstrap中被调用，其调用方式为 <code>compile（scope）</code>
这里只用有一个实参，但是compile作为$compile service暴露出来的函数，可以被手动点用，在调用时，
第二个参数为cloneConnectFn，此函数使用时，$compileNodes被clone，被被cloneConnectFn函数所调用，
第三个参数为transcludeControllers，次参数为一个数组，它使用时，分别为$compileNodes赋予一个Controller</li><li>关于compositeLinkFn的调用，此时其中含有多层递归，其具体递归的深度和node的结构有关
每次层中，可能有好几个node，要看这个node有没有兄弟节点，
对于一个node来说，最多可能有两个函数，分别是nodeLinkFn和childLinkFn，nodeLinkFn为执行当前node的函数，childLinkFn为执行下一代node的函数
nodeLinkFn为applyDirectivesToNode的返回值，childLinkFn函数为递归调用的compileNodes的返回值。
当nodeLinkFn存在时，执行nodeLinkFn，其中该函数的第一个参数为childLinkFn，这样吧子代node的执行放在nodeLinkFn内部</li><li>compositeLinkFn的调用，有四个参数，其中publicLinkFn函数中的的调用方式是
<code>compositeLinkFn(scope,$linkNode,$linkNode)</code></li></ol></body>
</html>